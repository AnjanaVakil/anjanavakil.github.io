<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode🌲 on Anjana</title>
    <link>https://anjanavakil.github.io/categories/leetcode/</link>
    <description>Recent content in LeetCode🌲 on Anjana</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 28 Jul 2022 08:15:48 +0800</lastBuildDate><atom:link href="https://anjanavakil.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode Graph</title>
      <link>https://anjanavakil.github.io/post/leetcode-graph/</link>
      <pubDate>Thu, 28 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-graph/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 图 如果要求在无权图中找出两个节点之间的最短距离，那么广度优先搜索可能是更合适的算法。 如果面试题要求找出符</description>
    </item>
    
    <item>
      <title>LeetCode Queue</title>
      <link>https://anjanavakil.github.io/post/leetcode-queue/</link>
      <pubDate>Thu, 21 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-queue/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 队列 滑动窗口 剑指 Offer II 041. 滑动窗口的平均值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MovingAverage { public: queue&amp;lt;int&amp;gt; q; int</description>
    </item>
    
    <item>
      <title>LeetCode Stack</title>
      <link>https://anjanavakil.github.io/post/leetcode-stack/</link>
      <pubDate>Wed, 20 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-stack/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 栈 剑指 Offer II 036. 后缀表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int evalRPN(vector&amp;lt;string&amp;gt;&amp;amp; tokens) { stack&amp;lt;int&amp;gt; s; int a,b,res; for(string&amp;amp;</description>
    </item>
    
    <item>
      <title>LeetCode Dynamic Programming</title>
      <link>https://anjanavakil.github.io/post/leetcode-dp/</link>
      <pubDate>Mon, 18 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-dp/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 动态规划</description>
    </item>
    
    <item>
      <title>LeetCode Heap</title>
      <link>https://anjanavakil.github.io/post/leetcode-heap/</link>
      <pubDate>Fri, 08 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-heap/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 堆 如果面试题需要求出一个动态数据集合中的最大值或最小值，那么可以考虑使用堆来解决问题。最小堆经常用来求取</description>
    </item>
    
    <item>
      <title>LeetCode Tree</title>
      <link>https://anjanavakil.github.io/post/leetcode-tree/</link>
      <pubDate>Tue, 05 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-tree/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 树 二叉树的深度优先搜索 前序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; res; stack&amp;lt;TreeNode*&amp;gt; s; TreeNode* cur=root; while(cur || !s.empty()){</description>
    </item>
    
    <item>
      <title>LeetCode Sort</title>
      <link>https://anjanavakil.github.io/post/leetcode-sort/</link>
      <pubDate>Fri, 01 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-sort/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 排序 Interval 56 Merge Intervals 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { sort(intervals.begin(),intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; //avoid an edge case res.push_back(intervals[0]); for(int i=1;i&amp;lt;intervals.size();i++){ int start=intervals[i][0],end=intervals[i][1]; int lastEnd=res[res.size()-1][1]; if(start&amp;lt;=lastEnd){ //the reason of</description>
    </item>
    
    <item>
      <title>LeetCode LinkedList</title>
      <link>https://anjanavakil.github.io/post/leetcode-linkedlist/</link>
      <pubDate>Fri, 28 Jan 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-linkedlist/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 链表 单向链表 定义 1 2 3 4 5 6 7 8 public class ListNode { public int val; public ListNode next; public ListNode(int val) { this.val = val; } } 链表插入 1 2 3 4 5 6 7 8 9 10 11 public ListNode</description>
    </item>
    
    <item>
      <title>LeetCode Backtrack</title>
      <link>https://anjanavakil.github.io/post/leetcode-backtrack/</link>
      <pubDate>Wed, 26 Jan 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-backtrack/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 回溯法 用回溯法解决问题的过程可以形象地用一个树形结构表示，求解问题的每个步骤可以看作树中的一个节点。如果</description>
    </item>
    
    <item>
      <title>LeetCode HashTable</title>
      <link>https://anjanavakil.github.io/post/leetcode-hashtable/</link>
      <pubDate>Wed, 26 Jan 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-hashtable/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 哈希表 032. 有效的变位词 剑指 Offer II 032. 有效的变位词 排序 1 2 3 4 5 6 7 8 9 10 class Solution { public: bool isAnagram(string s, string t) { if(s.length()!=t.length()) return false; if(s==t) return false; sort(s.begin(),s.end()); sort(t.begin(),t.end()); return</description>
    </item>
    
    <item>
      <title>LeetCode Binary Search</title>
      <link>https://anjanavakil.github.io/post/leetcode-binary-search/</link>
      <pubDate>Tue, 25 Jan 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-binary-search/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 二分查找 关于left&amp;lt;=right: 当left等于right时，查找范围是长度为1的子数组。长度为</description>
    </item>
    
    <item>
      <title>LeetCode String</title>
      <link>https://anjanavakil.github.io/post/leetcode-string/</link>
      <pubDate>Sun, 23 Jan 2022 14:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-string/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 字符串 014. 字符串中的变位词 剑指 Offer II 014. 字符串中的变位词 双指针 + 哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</description>
    </item>
    
    <item>
      <title>LeetCode Array</title>
      <link>https://anjanavakil.github.io/post/leetcode-array/</link>
      <pubDate>Sat, 22 Jan 2022 14:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-array/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 数组 006. 排序数组中两个数字之和 剑指 Offer II 006. 排序数组中两个数字之和 二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class</description>
    </item>
    
    <item>
      <title>LeetCode Number</title>
      <link>https://anjanavakil.github.io/post/leetcode-number/</link>
      <pubDate>Thu, 20 Jan 2022 14:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-number/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 整数 001. 整数除法 剑指 Offer II 001. 整数除法 由于是整数除法并且除数不等于0，因此商的绝对值一定&amp;lt;=被除数的绝对</description>
    </item>
    
    <item>
      <title>LeetCode Recursion</title>
      <link>https://anjanavakil.github.io/post/leetcode-recursion/</link>
      <pubDate>Tue, 18 Jan 2022 14:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-recursion/</guid>
      <description>自己一直还是比较努力的，不知道“摆烂”是种什么状态，但最近的自己迷茫，深深感觉到现在的自己不就处于“摆烂”的状态吗？没有目标没有计划，只失败</description>
    </item>
    
  </channel>
</rss>
