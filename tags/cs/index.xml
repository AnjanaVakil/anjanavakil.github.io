<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS💻 on Anjana</title>
    <link>https://anjanavakil.github.io/tags/cs/</link>
    <description>Recent content in CS💻 on Anjana</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 26 Sep 2022 08:15:48 +0800</lastBuildDate><atom:link href="https://anjanavakil.github.io/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Formal Methods</title>
      <link>https://anjanavakil.github.io/post/formal-methods/</link>
      <pubDate>Mon, 26 Sep 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/formal-methods/</guid>
      <description>Use of Formal Methods at Amazon Web Services To safeguard that data, the core of each service relies on fault-tolerant distributed algorithms for replication, consistency, concurrency control, auto-scaling, load balancing, and other coordination tasks.
We use deep design reviews, code reviews, static code analysis, stress testing, fault-injection testing, and many other techniques, but we still find that subtle bugs can hide in complex concurrent fault-tolerant systems. One reason for this problem is that human intuition is poor at estimating the true probability of supposedly &amp;rsquo;extremely rare&amp;rsquo; combinations of events in systems operating at a scale of millions of requests per second.</description>
    </item>
    
    <item>
      <title>Software Engineering: A Practitioner&#39;s Approach</title>
      <link>https://anjanavakil.github.io/post/software-engineering/</link>
      <pubDate>Sun, 11 Sep 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/software-engineering/</guid>
      <description>研一&amp;quot;软件工程与软件过程&amp;quot;课程书籍——SEPA(Software Engineering: A Practitioner&amp;rsquo;s Approach)笔记。 PREFACE CHAPTER 1: Software And Software Engineering KEY CONCEPTS: application domains characteristics of</description>
    </item>
    
    <item>
      <title>Middleware</title>
      <link>https://anjanavakil.github.io/post/middleware/</link>
      <pubDate>Thu, 01 Sep 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/middleware/</guid>
      <description>缓存中间件Redis Redis使用 Redis自定义注入Bean组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37</description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>https://anjanavakil.github.io/post/k8s/</link>
      <pubDate>Sat, 20 Aug 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/k8s/</guid>
      <description>豆瓣🔗： Kubernetes网络权威指南：基础、原理与实践 容器网络虚拟化基础 macOS M1下使用docker运行linux(centos)： 1 docker run -it</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>https://anjanavakil.github.io/post/go/</link>
      <pubDate>Thu, 11 Aug 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/go/</guid>
      <description>编程语言都是相通的，所以通过记录与其他语言不同的部分学习Go语言。 Reference: Go 语言教程 Go基础语法 1、当标识符（包括常量、变量、类型、函数名、结构字</description>
    </item>
    
    <item>
      <title>Java Concurrentcy-JUC</title>
      <link>https://anjanavakil.github.io/post/juc/</link>
      <pubDate>Mon, 01 Aug 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/juc/</guid>
      <description>Package java.util.concurrent Description Utility classes commonly useful in concurrent programming. This package includes a few small standardized extensible frameworks, as well as some classes that provide useful functionality and are otherwise tedious or difficult to implement. Here are brief descriptions of the main components. See also the java.util.concurrent.locks and java.util.concurrent.atomic packages. Executors Interfaces. Executoris a simple standardized interface for defining custom thread-like subsystems, including thread pools, asynchronous I/O, and lightweight</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://anjanavakil.github.io/post/sql/</link>
      <pubDate>Sat, 30 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/sql/</guid>
      <description>Difference between count() 参考🔗： What is the Difference Between COUNT(*), COUNT(1), COUNT(column name), and COUNT(DISTINCT column name)? 很不错的文章，果然还是看英文靠谱点。 The COUNT() function belongs to SQL’s aggregate functions. It counts the number of rows that satisfy the criteria defined in the parentheses. It does not return the rows</description>
    </item>
    
    <item>
      <title>LeetCode Graph</title>
      <link>https://anjanavakil.github.io/post/leetcode-graph/</link>
      <pubDate>Thu, 28 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-graph/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 图 图的搜索 如果要求在无权图中找出两个节点之间的最短距离，那么广度优先搜索可能是更合适的算法。 如果面试题要</description>
    </item>
    
    <item>
      <title>The Effective Engineer</title>
      <link>https://anjanavakil.github.io/post/the-effective-engineer/</link>
      <pubDate>Mon, 25 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/the-effective-engineer/</guid>
      <description>豆瓣🔗： The Effective Engineer: How to Leverage Your Efforts in Software Engineering to Make a Disproportionate and Meaningful Impact Talks at Google🔗: The Effective Engineer | Edmond Lau | Talks at Google 大概是3、4月份读的英文版，发现7月份出了翻译版，对我来</description>
    </item>
    
    <item>
      <title>Java源码阅读分析</title>
      <link>https://anjanavakil.github.io/post/java-source-code/</link>
      <pubDate>Fri, 22 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/java-source-code/</guid>
      <description>2022.8.9总结反思：看起来好像分析源码挺久了，但是每次都只是读一遍源码、注释和Java doc，然后Command+C复制、Comman</description>
    </item>
    
    <item>
      <title>LeetCode Queue</title>
      <link>https://anjanavakil.github.io/post/leetcode-queue/</link>
      <pubDate>Thu, 21 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-queue/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 队列 滑动窗口 剑指 Offer II 041. 滑动窗口的平均值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MovingAverage { public: queue&amp;lt;int&amp;gt; q; int</description>
    </item>
    
    <item>
      <title>LeetCode Stack</title>
      <link>https://anjanavakil.github.io/post/leetcode-stack/</link>
      <pubDate>Wed, 20 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-stack/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 栈 剑指 Offer II 036. 后缀表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int evalRPN(vector&amp;lt;string&amp;gt;&amp;amp; tokens) { stack&amp;lt;int&amp;gt; s; int a,b,res; for(string&amp;amp;</description>
    </item>
    
    <item>
      <title>LeetCode Dynamic Programming</title>
      <link>https://anjanavakil.github.io/post/leetcode-dp/</link>
      <pubDate>Mon, 18 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-dp/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 动态规划 1D DP 70 Climbing Stairs 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int climbStairs(int n) { vector&amp;lt;int&amp;gt; dp(n+1); dp[0]=1; dp[1]=1; for(int i=2;i&amp;lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } }; 时间复杂度：O(n) 空</description>
    </item>
    
    <item>
      <title>StringUtils: leftPad&#43;rightPad</title>
      <link>https://anjanavakil.github.io/post/stringutils/</link>
      <pubDate>Fri, 15 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/stringutils/</guid>
      <description>StringUtils的leftpad和righted方法源码分析 依赖： 1 2 3 4 5 6 &amp;lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.12.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; leftPad: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</description>
    </item>
    
    <item>
      <title>Spring Batch</title>
      <link>https://anjanavakil.github.io/post/springbatch-notes/</link>
      <pubDate>Mon, 11 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/springbatch-notes/</guid>
      <description>官网示例： Creating a Batch Service Create a Business Class Person.java: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package com.example.batchprocessing; public class Person { private String lastName; private String firstName; public Person() { } public Person(String firstName,</description>
    </item>
    
    <item>
      <title>LeetCode Heap</title>
      <link>https://anjanavakil.github.io/post/leetcode-heap/</link>
      <pubDate>Fri, 08 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-heap/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 堆 如果面试题需要求出一个动态数据集合中的最大值或最小值，那么可以考虑使用堆来解决问题。最小堆经常用来求取</description>
    </item>
    
    <item>
      <title>LeetCode Tree</title>
      <link>https://anjanavakil.github.io/post/leetcode-tree/</link>
      <pubDate>Tue, 05 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-tree/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 树 二叉树的DFS 前序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; res; stack&amp;lt;TreeNode*&amp;gt; s; TreeNode* cur=root; while(cur || !s.empty()){ while(cur){ res.push_back(cur-&amp;gt;val); s.push(cur);</description>
    </item>
    
    <item>
      <title>LeetCode Sort</title>
      <link>https://anjanavakil.github.io/post/leetcode-sort/</link>
      <pubDate>Fri, 01 Jul 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/leetcode-sort/</guid>
      <description>LeetCode + 《剑指Offer II》刷题笔记。 排序 Interval 56 Merge Intervals 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { sort(intervals.begin(),intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; //avoid an edge case res.push_back(intervals[0]); for(int i=1;i&amp;lt;intervals.size();i++){ int start=intervals[i][0],end=intervals[i][1]; int lastEnd=res[res.size()-1][1]; if(start&amp;lt;=lastEnd){ //the reason of</description>
    </item>
    
    <item>
      <title>Vue</title>
      <link>https://anjanavakil.github.io/post/vue/</link>
      <pubDate>Mon, 20 Jun 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/vue/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://anjanavakil.github.io/post/jvm/</link>
      <pubDate>Sun, 12 Jun 2022 08:15:48 +0800</pubDate>
      
      <guid>https://anjanavakil.github.io/post/jvm/</guid>
      <description>Java SE 8虚拟机规范：The Java® Virtual Machine Specification-Java SE 8 Edition 类加载子系统 运行时数据区概述及线程 Run-Time Data Areas The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual</description>
    </item>
    
  </channel>
</rss>
