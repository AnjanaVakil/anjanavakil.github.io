<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>《凤凰架构》架构师的视角 - Anjana</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Anjana" />
  <meta name="description" content="架构师的视角 第2章 访问远程服务 2.1 远程服务调用 2.1.1 进程间通信 调用本地方法： 1 2 3 4 5 6 7 8 // Caller: 调用者，代码里的main() // Callee: 被调用者，代码里的" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.93.0" />


<link rel="canonical" href="https://anjanavakil.github.io/post/the-fenix-project2/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa4b2b9f31b5c6d0b683db81157a9226e17b06e61911791ab547242a4a0556f2.css" integrity="sha256-&#43;ksrnzG1xtC2g9uBFXqSJuF7BuYZEXkatUckKkoFVvI=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="《凤凰架构》架构师的视角" />
<meta property="og:description" content="架构师的视角 第2章 访问远程服务 2.1 远程服务调用 2.1.1 进程间通信 调用本地方法： 1 2 3 4 5 6 7 8 // Caller: 调用者，代码里的main() // Callee: 被调用者，代码里的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://anjanavakil.github.io/post/the-fenix-project2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-02T08:15:48+08:00" />
<meta property="article:modified_time" content="2022-04-02T08:15:48+08:00" />

<meta itemprop="name" content="《凤凰架构》架构师的视角">
<meta itemprop="description" content="架构师的视角 第2章 访问远程服务 2.1 远程服务调用 2.1.1 进程间通信 调用本地方法： 1 2 3 4 5 6 7 8 // Caller: 调用者，代码里的main() // Callee: 被调用者，代码里的"><meta itemprop="datePublished" content="2022-04-02T08:15:48+08:00" />
<meta itemprop="dateModified" content="2022-04-02T08:15:48+08:00" />
<meta itemprop="wordCount" content="15112">
<meta itemprop="keywords" content="Java☕️,CS💻," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《凤凰架构》架构师的视角"/>
<meta name="twitter:description" content="架构师的视角 第2章 访问远程服务 2.1 远程服务调用 2.1.1 进程间通信 调用本地方法： 1 2 3 4 5 6 7 8 // Caller: 调用者，代码里的main() // Callee: 被调用者，代码里的"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Anjana</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Anjana
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://anjanavakil.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">《凤凰架构》架构师的视角</h1>
      
      <div class="post-meta">
        <time datetime="2022-04-02" class="post-time">
          2022-04-02
        </time>
        <div class="post-category">
            <a href="https://anjanavakil.github.io/categories/springcloud/"> SpringCloud🌵 </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第2章-访问远程服务">第2章 访问远程服务</a>
      <ul>
        <li><a href="#21-远程服务调用">2.1 远程服务调用</a></li>
        <li><a href="#211-进程间通信">2.1.1 进程间通信</a></li>
        <li><a href="#212-通信的成本">2.1.2 通信的成本</a></li>
        <li><a href="#213-三个基本问题">2.1.3 三个基本问题</a></li>
        <li><a href="#213-统一的rpc">2.1.3 统一的RPC</a></li>
        <li><a href="#213-分裂的rpc">2.1.3 分裂的RPC</a></li>
        <li><a href="#22-rest设计风格">2.2 REST设计风格</a></li>
        <li><a href="#221-理解rest">2.2.1 理解REST</a></li>
        <li><a href="#222-restful的系统">2.2.2 RESTful的系统</a></li>
        <li><a href="#223-rmm">2.2.3 RMM</a></li>
        <li><a href="#223-不足与争议">2.2.3 不足与争议</a></li>
      </ul>
    </li>
    <li><a href="#第3章-事务处理">第3章 事务处理</a>
      <ul>
        <li><a href="#31-本地事务">3.1 本地事务</a></li>
        <li><a href="#311-实现原子性和持久性">3.1.1 实现原子性和持久性</a></li>
        <li><a href="#312-实现隔离性">3.1.2 实现隔离性</a></li>
        <li><a href="#32-全局事务">3.2 全局事务</a></li>
      </ul>
    </li>
    <li><a href="#第4章-透明多级分流系统">第4章 透明多级分流系统</a></li>
    <li><a href="#第5章-架构安全性">第5章 架构安全性</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="架构师的视角">架构师的视角</h1>
<h2 id="第2章-访问远程服务">第2章 访问远程服务</h2>
<h3 id="21-远程服务调用">2.1 远程服务调用</h3>
<h3 id="211-进程间通信">2.1.1 进程间通信</h3>
<p>调用本地方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Caller: 调用者，代码里的main()
</span></span></span><span class="line"><span class="cl"><span class="c1">// Callee: 被调用者，代码里的println()
</span></span></span><span class="line"><span class="cl"><span class="c1">// Call Site: 调用点，即发生方法调用的指令流位置
</span></span></span><span class="line"><span class="cl"><span class="c1">// Parameter: 参数，由Caller传递给Callee的数据，即&#34;hello world&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// Retval: 返回值，由Callee传递给Caller的数据；如果方法正常结束，返回void，如果方法异常完成，返回对应的异常。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello world&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在完全不考虑编译器优化的前提下，程序运行至调用println()方法输出hello world这行时，计算机（物理机或者虚拟机）要完成以下几项工作。</p>
<p>1）传递方法参数：将字符串hello world的<code>引用地址压栈</code>。</p>
<p>2）确定方法版本：根据println()方法的签名，确定其执行版本。这其实并不是一个简单的过程，无论是<code>编译时静态解析</code>，还是<code>运行时动态分派</code>，都必须根据某些语言规范中明确定义的原则，找到明确的Callee，“明确”是指唯一的一个Callee，或者有严格优先级的多个Callee，譬如不同的重载版本。</p>
<p>3）执行被调方法：从栈中弹出Parameter的值或引用，并以此为输入，执行Callee内部的逻辑。这里我们只关心方法是如何调用的，而不关心方法内部具体是如何执行的。</p>
<p>4）返回执行结果：将Callee的执行结果压栈，并将程序的指令流恢复到Call Site的下一条指令，继续向下执行。</p>
<p>第一步和第四步所做的传递参数、传回结果都依赖于栈内存，如果Caller与Callee分属不同的进程，就不会拥有相同的栈内存，此时将参数在Caller进程的内存中压栈，对于Callee进程的执行毫无意义。</p>
<p>因此就有了两个进程之间如何交换数据的问题，这件事情在计算机科学中被称为“进程间通信”（Inter-Process Communication，IPC）。</p>
<p>IPC的解决方法：</p>
<p>1、管道（Pipe）或者具名管道（Named Pipe）：管道类似于两个进程间的桥梁，可通过管道在进程间传递少量的字符流或字节流。</p>
<p><code>普通管道</code>只用于<code>有亲缘关系的进程</code>（由一个进程启动的另外一个进程）间的通信</p>
<p><code>具名管道</code>摆脱了普通管道没有名字的限制，除具有管道的所有功能外，它还允许<code>无亲缘关系的进程间</code>的通信。</p>
<p>管道典型的应用就是命令行中的“|”操作符，譬如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ps -ef <span class="p">|</span> grep java
</span></span></code></pre></td></tr></table>
</div>
</div><p>ps与grep都有独立的进程，以上命令就是通过管道操作符“|”将ps命令的<code>标准输出</code>连接到grep命令的<code>标准输入</code>上。</p>
<p>2、信号（Signal）：信号用于通知目标进程有某种事件发生。除了进程间通信外，进程还可以给进程自身发送信号。信号的典型应用是kill命令，譬如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">kill</span> -9 pid
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上命令即表示由Shell进程向指定PID的进程发送SIGKILL信号。</p>
<p>3、信号量（Semaphore）：信号量用于在两个进程之间同步协作手段，它相当于操作系统提供的一个特殊变量，程序可以在上面进行wait()和notify()操作。</p>
<p>4、消息队列（Message Queue）：以上三种方式只适合传递少量消息，POSIX标准中定义了可用于进程间数据量较多的通信的消息队列。进程可以向队列添加消息，被赋予读权限的进程还可以从队列消费消息。消息队列克服了信号承载信息量少、管道只能用于无格式字节流以及缓冲区大小受限等缺点，但实时性相对受限。</p>
<p>5、共享内存（Shared Memory）：允许多个进程访问同一块公共内存空间，这是效率最高的进程间通信形式。原本每个进程的内存地址空间都是相互隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的程序接口。当一块内存被多进程共享时，各个进程往往会与其他通信机制，譬如与信号量结合使用，来达到进程间同步及互斥的协调操作。</p>
<p>6、本地套接字接口（IPC Socket）：消息队列与共享内存只适合单机多进程间的通信，套接字接口则是更普适的进程间通信机制，可用于不同机器之间的进程通信。</p>
<p>套接字（Socket）起初是由UNIX系统的BSD分支开发出来的，现在已经移植到所有主流的操作系统上。出于效率考虑，当仅限于本机进程间通信时，套接字接口是被优化过的，不会经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等操作，只是简单地将应用层数据从一个进程<code>复制</code>到另一个进程，这种进程间通信方式即本地套接字接口（UNIX Domain Socket），又叫作IPC Socket。</p>
<h3 id="212-通信的成本">2.1.2 通信的成本</h3>
<p>IPC Socket不仅适用于本地相同机器的不同进程间通信，由于Socket是网络栈的统一接口，它也能支持基于网络的跨机进程间通信。譬如</p>
<ul>
<li>Linux系统的图形化界面</li>
<li>X Window服务器</li>
<li>GUI程序之间的交互</li>
</ul>
<p>就是由这套机制来实现的。这样做的好处是，由于Socket是各个操作系统都提供的标准接口，完全有可能把远程方法调用的通信细节隐藏在操作系统底层，从应用层面上来看可以做到远程调用与本地的进程间通信在编码上完全一致。</p>
<p>首次提出远程服务调用的定义：</p>
<p>远程服务调用是指位于互不重合的内存地址空间中的两个程序，在语言层面上，以同步的方式使用带宽有限的信道来传输程序控制信息。</p>
<h3 id="213-三个基本问题">2.1.3 三个基本问题</h3>
<h4 id="1如何表示数据">1、如何表示数据</h4>
<p>每种RPC协议都应该要有对应的序列化协议，譬如：</p>
<ul>
<li>ONC RPC的外部数据表示（External Data Representation, XDR）</li>
<li>CORBA的通用数据表示（Common Data Representation, CDR）</li>
<li>Java RMI的Java对象序列化流协议（Java Object Serialization Stream Protocol）</li>
<li>gRPC的Protocol Buffers</li>
<li>Web Service的XML序列化</li>
<li>众多轻量级RPC支持的JSON序列化</li>
</ul>
<h4 id="2如何传递数据">2、如何传递数据</h4>
<p>如何传递数据，准确地说，是指如何通过网络，在两个服务的Endpoint之间相互操作、交换数据。这里“交换数据”通常指的是应用层协议，实际传输一般是基于TCP、UDP等标准的传输层协议来完成的。两个服务交互不是只扔个序列化数据流来表示参数和结果就行，许多在此之外的信息，譬如异常、超时、安全、认证、授权、事务等，都可能产生双方需要交换信息的需求。</p>
<p>在计算机科学中，专门有一个名词“Wire Protocol”来表示这种两个Endpoint之间交换这类数据的行为，常见的Wire Protocol如下：</p>
<ul>
<li>Java RMI的Java远程消息交换协议（Java Remote Message Protocol, JRMP，也支持RMI-IIOP）</li>
<li>CORBA的互联网ORB间协议（Internet Inter ORB Protocol，IIOP，是GIOP协议在IP协议上的实现版本）</li>
<li>DDS的实时发布订阅协议（Real Time Publish Subscribe Protocol, RTPS）</li>
<li>Web Service的简单对象访问协议（Simple Object Access Protocol, SOAP）</li>
</ul>
<p>如果要求足够简单，双方都是HTTP Endpoint，直接使用HTTP协议也是可以的（如JSON-RPC）</p>
<h4 id="3如何表示方法">3、如何表示方法</h4>
<p>表示方法的协议有：</p>
<ul>
<li>唯一的绝不重复的编码方案UUID（Universally Unique Identifier）</li>
<li>Android的Android接口定义语言（Android Interface Definition Language, AIDL)</li>
<li>CORBA的OMG接口定义语言（OMG Interface Definition Language, OMG IDL）</li>
<li>Web Service的Web服务描述语言（Web Service Description Language, WSDL)</li>
<li>JSON-RPC的JSON Web服务协议（JSON Web Service Protocol, JSON-WSP）</li>
</ul>
<h3 id="213-统一的rpc">2.1.3 统一的RPC</h3>
<p>面向透明的、简单的RPC协议，如<code>DCE/RPC、DCOM、Java RMI</code>，要么依赖于操作系统，要么依赖于特定语言，总有一些先天约束；</p>
<p>那些面向通用的、普适的RPC协议，如<code>CORBA</code>，就无法逃过使用复杂性的困扰，CORBA烦琐的<code>OMG IDL、ORB</code>都是很好的佐证；</p>
<p>而那些意图通过技术手段来屏蔽复杂性的RPC协议，如<code>Web Service</code>，又不免受到性能问题的束缚。</p>
<p>简单、普适、高性能这三点，似乎真的很难同时满足。</p>
<h3 id="213-分裂的rpc">2.1.3 分裂的RPC</h3>
<p>现在，已经相继出现过</p>
<ul>
<li>RMI（Sun/Oracle）</li>
<li>Thrift（Facebook/Apache）</li>
<li>Dubbo（阿里巴巴/Apache）</li>
<li>gRPC（Google）</li>
<li>Motan1/2（新浪）</li>
<li>Finagle（Twitter）</li>
<li>brpc（百度/Apache）</li>
<li>.NET Remoting（微软）</li>
<li>Arvo（Hadoop）</li>
<li>JSON-RPC 2.0（公开规范，JSON-RPC工作组）</li>
</ul>
<p>等难以穷举的协议和框架。这些RPC功能、特点不尽相同，有的是某种语言私有，有的支持跨越多种语言，有的运行在应用层HTTP协议之上，有的直接运行于传输层TCP/UDP协议之上，但并不存在哪一款是“最完美的RPC”。今时今日，任何一款具有生命力的RPC框架，都不再去追求大而全的“完美”，而是以某个具有针对性的特点作为主要的发展方向，举例分析如下。</p>
<p>1、朝着<code>面向对象</code>发展，不满足于RPC将面向过程的编码方式带到分布式，希望在分布式系统中也能够进行<code>跨进程的面向对象编程</code>，代表为<code>RMI、.NET Remoting</code>，之前的CORBA和DCOM也可以归入这类。这种方式有一个别名叫作<code>分布式对象（Distributed Object）</code>。</p>
<p>2、朝着<code>性能</code>发展，代表为gRPC和Thrift。</p>
<p>决定RPC性能的主要因素有两个：<code>序列化效率和信息密度</code>。序列化效率很好理解，序列化输出结果的容量越小，速度越快，效率自然越高；信息密度则取决于协议中有效负载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低，SOAP使用XML拙劣的性能表现就是前车之鉴。</p>
<p>gRPC和Thrift都有自己优秀的专有序列化器，而传输协议方面，gRPC是基于<code>HTTP/2</code>的，支持<code>多路复用和Header压缩</code>，Thrift则<code>直接基于传输层的TCP协议</code>来实现，省去了应用层协议的额外开销。</p>
<p>3、朝着<code>简化</code>发展，代表为<code>JSON-RPC</code>，说要选功能最强、速度最快的RPC可能会很有争议，但选功能弱的、速度慢的，JSON-RPC肯定会是候选人之一。牺牲了功能和效率，换来的是协议的简单轻便，接口与格式都更为通用，尤其适合用于<code>Web浏览器这类一般不会有额外协议支持、额外客户端支持</code>的应用场合。</p>
<p>经历了RPC框架的“战国时代”，开发者们终于认可了不同的RPC框架所提供的特性或多或少是有矛盾的，很难有某一种框架能满足所有需求。</p>
<h3 id="22-rest设计风格">2.2 REST设计风格</h3>
<p>REST: 面向资源的调用方式</p>
<p>RPC: 面向过程的调用方式</p>
<h3 id="221-理解rest">2.2.1 理解REST</h3>
<p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Architectural Styles and the Design of Network-based Software Architectures</a></p>
<p>中文翻译版：<a href="https://www.infoq.cn/minibook/web-based-apps-archit-design">《架构风格与基于网络的软件架构设计》</a></p>
<p>REST(Representational State Transfer, 表征状态转移)</p>
<p>先理解什么是HTTP，再配合一些实际例子来对两者进行类比，以更清楚地了解REST，会发现REST实际上是“HTT”（Hypertext Transfer）的进一步抽象，两者的关系就如同接口与实现类的关系一般。</p>
<blockquote>
<p>现在，“超文本”一词已被普遍接受，它指的是能够进行分支判断和差异响应的文本，相应地，“超媒体”一词指的是能够进行分支判断和差异响应的图像、电影和声音（也包括文本）的复合体。</p>
<p>——Theodor Holm Nelson，Literary Machines，1992</p>
</blockquote>
<h3 id="222-restful的系统">2.2.2 RESTful的系统</h3>
<p>REST风格系统的六大原则：</p>
<p>1、客户端与服务端分离（Client-Server）</p>
<p>将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来，有助于提高用户界面的跨平台的可移植性。</p>
<p>2、无状态（Stateless）</p>
<p>REST希望<code>服务端不用负责维护状态</code>，每一次从客户端发送的请求中，应包括所有必要的上下文信息，<code>会话信息也由客户端负责保存维护</code>，<code>服务端只依据客户端传递的状态来执行业务处理逻辑</code>，驱动整个应用的状态变迁。客户端承担状态维护职责以后，会产生一些新的问题，譬如身份认证、授权等可信问题，它们都应有针对性的解决方案。</p>
<p>3、可缓存（Cacheability）</p>
<p>无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。</p>
<p>“降低网络性”：某个功能使用有状态的设计时只需要一次（或少量）请求就能完成，使用无状态的设计时则可能会需要多次请求，或者在请求中带有额外冗余的信息。为了缓解这个矛盾，REST希望软件系统能够如同万维网一样，允许客户端和中间的通信传递者（譬如代理）将部分服务端的应答缓存起来。</p>
<p>4、分层系统（Layered System）</p>
<p>这里所指的分层并不是表示层、服务层、持久层这种意义上的分层，而是指客户端一般不需要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样也便于缓存、伸缩和安全策略的部署。该原则的典型应用是内容分发网络（Content Distribution Network，CDN）。</p>
<p>5、统一接口（Uniform Interface）</p>
<p>这是REST的另一条核心原则，REST希望开发者面向资源编程，希望软件系统设计的重点放在抽象系统该有哪些资源，而不是抽象系统该有哪些行为（服务）上。</p>
<p>如果想要在架构设计中合理恰当地利用统一接口，Fielding建议系统应能做到每次请求中都包含<code>资源的ID</code>，所有操作均通过资源ID来进行；建议每个资源都应该是<code>自描述</code>的消息；建议通过<code>超文本</code>来驱动应用状态的转移。</p>
<p>6、按需代码（Code-On-Demand）</p>
<p>按需代码被Fielding列为一条可选原则。它是指任何按照客户端（譬如浏览器）的请求，将<code>可执行的软件程序</code>从服务端发送到客户端的技术。</p>
<h3 id="223-rmm">2.2.3 RMM</h3>
<p>RESTful Web APIs和RESTful Web Services的作者Leonard Richardson曾提出一个衡量“服务有多么REST”的Richardson成熟度模型（Richardson Maturity Model，RMM），以便让那些原本不使用REST的系统，能够逐步地导入REST。</p>
<p>Richardson将服务接口“REST的程度”从低到高，分为0至3级。</p>
<ul>
<li>第0级（The Swamp of Plain Old XML）：完全不REST。</li>
<li>第1级（Resources）：开始引入资源的概念。</li>
<li>第2级（HTTP Verbs）：引入统一接口，映射到HTTP协议的方法上。</li>
<li>第3级（Hypermedia Controls）：超媒体控制，在本文里面的说法是“超文本驱动”，在Fielding论文里的说法是“Hypertext As The Engine Of Application State，HATEOAS”，其实都是指同一件事情。</li>
</ul>
<h3 id="223-不足与争议">2.2.3 不足与争议</h3>
<p>REST没有传输可靠性支持。</p>
<p>是的，并没有。在HTTP中发送一个请求，你通常会收到一个与之相对的响应，譬如HTTP/1.1 200 OK或者HTTP/1.1 404 Not Found等。但如果你没有收到任何响应，那就无法确定消息是没有发送出去，抑或是没有从服务端返回，这其中的关键差别是服务端是否被触发了某些处理？</p>
<p>应对传输可靠性最简单粗暴的做法是把消息再重发一遍。这种简单处理能够成立的前提是服务应具有<code>幂等性（Idempotency）</code>，即<code>服务被重复执行多次的效果与执行一次是相等的</code>。HTTP协议要求GET、PUT和DELETE应具有幂等性，我们把REST服务映射到这些方法时，也应当保证幂等性。</p>
<p>对于POST方法，曾经有过一些专门的提案，如POE（POST Once Exactly），但并未得到IETF的认可。对于POST的重复提交，浏览器会出现相应警告，如Chrome中“确认重新提交表单”的提示，对于服务端，就应该做预校验，如果发现可能重复，则返回<code>HTTP/1.1 425 Too Early</code>。</p>
<p>另外，Web Service中有WS-ReliableMessaging功能协议用于支持消息可靠投递。类似的，由于REST没有采用额外的Wire Protocol，所以除了事务、可靠传输这些功能以外，一定还可以在WS-*协议中找到很多REST不支持的特性。</p>
<h2 id="第3章-事务处理">第3章 事务处理</h2>
<p>原子性（Atomic）：</p>
<p>在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。</p>
<p>隔离性（Isolation）：</p>
<p>在不同的业务处理过程中，事务保证了各业务正在读、写的数据相互独立，不会彼此影响。</p>
<p>持久性（Durability）：</p>
<p>事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。</p>
<p>内部一致性：</p>
<p>当一个服务只使用一个数据源时，通过A、I、D来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为“内部一致性”。</p>
<p>外部一致性：</p>
<p>当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为“外部一致性”。</p>
<p>外部一致性问题通常很难使用A、I、D来解决，因为这样需要付出很大甚至不切实际的代价；但是外部一致性又是分布式系统中必然会遇到且必须要解决的问题，为此我们要转变观念，将一致性从“是或否”的二元属性转变为可以按不同强度分开讨论的多元属性，在确保代价可承受的前提下获得强度尽可能高的一致性保障，也正因如此，事务处理才从一个具体操作上的“编程问题”上升成一个需要全局权衡的“架构问题”。</p>
<h3 id="31-本地事务">3.1 本地事务</h3>
<p>本地事务（Local Transaction）：局部事务。本地事务是指仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。</p>
<p>本地事务是一种最基础的事务解决方案，只适用于<code>单个服务使用单个数据源</code>的场景。从应用角度看，它是直接依赖于<code>数据源本身提供的事务能力</code>来工作的，在程序代码层面，最多只能对事务接口做一层标准化的包装（如JDBC接口），并不能深入参与到事务的运作过程中，事务的开启、终止、提交、回滚、嵌套、设置隔离级别，乃至与应用代码贴近的事务传播方式，全部都要依赖<code>底层数据源</code>的支持才能工作，这一点与后续介绍的XA、TCC、SAGA等主要靠<code>应用程序代码来实现的事务</code>有着十分明显的区别。</p>
<p>举个例子，假设你的代码调用了JDBC中的Transaction::rollback()方法，方法的成功执行也并不一定代表事务就已经被成功回滚，如果数据表采用的引擎是<code>MyISAM</code>，那rollback()方法便是一项没有意义的空操作。因此，我们要想深入讨论本地事务，便不得不越过应用代码的层次，去了解一些数据库本身的事务实现原理，弄明白传统数据库管理系统是如何通过ACID来实现事务的。</p>
<p>ARIES理论（Algorithms for Recovery and Isolation Exploiting Semantic，ARIES）: 基于语义的恢复与隔离算法。</p>
<p>ARIES是现代数据库的基础理论，就算不能称所有的数据库都实现了ARIES，至少可以称现代的主流关系型数据库（Oracle、MS SQLServer、MySQL/InnoDB、IBM DB2、PostgreSQL，等等）在事务实现上都深受该理论的影响。</p>
<h3 id="311-实现原子性和持久性">3.1.1 实现原子性和持久性</h3>
<p><a href="https://cs.stanford.edu/people/chrismre/cs345/rl/aries.pdf">ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a> 着重解决了ACID的两个属性——原子性（A）和持久性（D）在算法层面上的实现问题。</p>
<p>由于写入中间状态与崩溃都是无法避免的，为了保证原子性和持久性，就只能在崩溃后采取恢复的补救措施，这种数据恢复操作被称为“崩溃恢复”（Crash Recovery或Failure Recovery或Transaction Recovery）。</p>
<p><strong>Commit Logging提交日志</strong> :</p>
<p>为了能够顺利地完成崩溃恢复，在磁盘中写入数据就不能像程序修改内存中的变量值那样，直接改变某表某行某列的某个值，而是必须将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即以仅进行<code>顺序追加</code>的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（<code>Commit Record</code>）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（<code>End Record</code>）表示事务已完成持久化，这种事务实现方法被称为“提交日志”（<code>Commit Logging</code>）。</p>
<p><strong>Write-Ahead Logging提前写入日志</strong>：</p>
<p>ARIES提出了“提前写入日志”（Write-Ahead Logging）的日志改进方案，所谓“提前写入”（Write-Ahead），就是允许在事务提交之前写入变动数据的意思。</p>
<p>Write-Ahead Logging按照<code>事务提交时点</code>，将<code>何时写入变动数据</code>划分为<code>FORCE</code>和<code>STEAL</code>两类情况。</p>
<ul>
<li>FORCE：当事务提交后，要求变动数据必须同时完成写入则称为FORCE，如果不强制变动数据必须同时完成写入则称为NO-FORCE。现实中绝大多数数据库采用的都是NO-FORCE策略，因为只要有了日志，变动数据随时可以持久化，从优化磁盘I/O性能考虑，没有必要强制数据写入时立即进行。</li>
<li>STEAL：在事务提交前，允许变动数据提前写入则称为STEAL，不允许则称为NO-STEAL。从优化磁盘I/O性能考虑，允许数据提前写入，有利于利用空闲I/O资源，也有利于节省数据库缓存区的内存。</li>
</ul>
<p><code>Commit Logging允许NO-FORCE，但不允许STEAL</code>。因为假如事务提交前就有部分变动数据写入磁盘，那一旦事务要回滚，或者发生了崩溃，这些提前写入的变动数据就都成了错误。</p>
<p><code>Write-Ahead Logging允许NO-FORCE，也允许STEAL</code>，它给出的解决办法是增加了另一种被称为Undo Log的日志类型，当变动数据写入磁盘前，必须先记录Undo Log，注明修改了哪个位置的数据、从什么值改成什么值等，以便在事务回滚或者崩溃恢复时根据Undo Log对提前写入的数据变动进行擦除。</p>
<p>Undo Log：回滚日志。</p>
<p>Redo Log：重做日志。用于崩溃恢复时重演数据变动的日志。</p>
<p>由于Undo Log的加入，Write-Ahead Logging在崩溃恢复时会经历以下三个阶段。</p>
<ul>
<li>分析阶段（Analysis）：该阶段从最后一次检查点（Checkpoint，可理解为在这个点之前所有应该持久化的变动都已安全落盘）开始扫描日志，找出所有没有End Record的事务，组成待恢复的事务集合，这个集合至少会包括事务表（Transaction Table）和脏页表（Dirty Page Table）两个组成部分。</li>
<li>重做阶段（Redo）：该阶段依据分析阶段中产生的待恢复的事务集合来重演历史（Repeat History），具体操作是找出所有包含Commit Record的日志，将这些日志修改的数据写入磁盘，写入完成后在日志中增加一条End Record，然后移出待恢复事务集合。</li>
<li>回滚阶段（Undo）：该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩下的都是需要回滚的事务，它们被称为Loser，根据Undo Log中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些Loser事务的目的。</li>
</ul>
<p>重做阶段和回滚阶段的操作都应该设计为幂等的。</p>
<p>Write-Ahead Logging是ARIES理论的一部分，整套ARIES拥有严谨、高性能等诸多优点，但这些也是以高度复杂为代价的。</p>
<p>数据库按照是否允许FORCE和STEAL可以产生四种组合。</p>
<p>FORCE和STEAL产生的四种组合与Undo Log、Redo Log之间的具体关系：</p>
<p><img src="/image/force-steal.png" alt="FORCE-STEAL"></p>
<p>从<code>优化磁盘I/O</code>的角度看，<code>NO-FORCE加STEAL</code>的组合的性能无疑是最高的；</p>
<p>从<code>算法实现与日志</code>的角度看，<code>NO-FORCE加STEAL</code>的组合的复杂度无疑也是最高的。</p>
<h3 id="312-实现隔离性">3.1.2 实现隔离性</h3>
<p><a href="http://vldb.org/conf/1990/P392.PDF">ARIES/KVL: A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operating on B-Tree Indexes</a> 则是现代数据库隔离性（I）奠基式的文章。</p>
<p>现代数据库均提供了以下三种锁。</p>
<ul>
<li>
<p>写锁（Write Lock，也叫作排他锁，eXclusive Lock，简写为X-Lock）：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。</p>
</li>
<li>
<p>读锁（Read Lock，也叫作共享锁，Shared Lock，简写为S-Lock）：<code>多个事务</code>可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据<code>只有它自己一个事务</code>加了读锁，则允许直接将其升级为写锁，然后写入数据。</p>
</li>
<li>
<p>范围锁（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。如下语句是典型的加范围锁的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">price</span><span class="o">&lt;</span><span class="mi">100</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>请注意“范围不能被写入”与“一批数据不能被写入”的差别，即不要把范围锁理解成一组排他锁的集合。加了范围锁后，不仅不能修改该范围内已有的数据，也不能在该范围内新增或删除任何数据，后者是一组排他锁的集合无法做到的。</p>
</li>
</ul>
<p><strong>隔离级别</strong>：</p>
<p>1、可串行化（Serializable）</p>
<p><code>串行化(Serializable)</code>访问提供了最高强度的隔离性。</p>
<p>并发控制（Concurrency Control）理论决定了<code>隔离程度与并发能力</code>是相互抵触的，隔离程度越高，并发访问时的吞吐量就越低。现代数据库一定会提供除可串行化以外的其他隔离级别供用户使用，让用户自主调节隔离级别，根本目的是让用户可以调节数据库的加锁方式，取得隔离性与吞吐量之间的平衡。</p>
<p>2、可重复读（Repeatable Read）</p>
<p>可串行化的下一个隔离级别是可重复读（Repeatable Read），可重复读对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。</p>
<p>可重复读比可串行化弱化的地方在于<code>幻读问题（Phantom Read）</code>，它是指在事务执行过程中，两个完全相同的范围查询得到了不同的结果集。原因是可重复读没有范围锁来禁止在该范围内插入新的数据，这是一个事务受到其他事务影响，隔离性被破坏的表现。</p>
<p><code>MySQL/InnoDB</code>的默认隔离级别为<code>可重复读</code>，但它在<code>只读事务</code>中可以完全避免幻读问题，譬如上面例子中事务T1只有查询语句，是一个只读事务，所以上述问题在MySQL中并不会出现。但在<code>读写事务</code>中，MySQL仍然会出现幻读问题，譬如例子中事务T1如果在其他事务插入新书后，不是重新查询一次数量，而是将所有小于100元的书改名，那就依然会受到新插入书的影响。</p>
<p>3、读已提交（Read Committed）</p>
<p>可重复读的下一个隔离级别是<code>读已提交（Read Committed）</code>，读已提交对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后会马上释放。</p>
<p>读已提交比可重复读弱化的地方在于<code>不可重复读问题（Non-Repeatable Read）</code>，它是指在事务执行过程中，对同一行数据的两次查询得到了不同的结果。</p>
<p>4、读未提交（Read Uncommitted）</p>
<p>读已提交的下一个级别是<code>读未提交（Read Uncommitted）</code>，它只会对事务涉及的数据加写锁，且一直持续到事务结束，但完全不加读锁。读未提交比读已提交弱化的地方在于<code>脏读问题（Dirty Read）</code>，它是指在事务执行过程中，一个事务读取到了另一个事务未提交的数据。</p>
<p><strong>MVCC</strong>:</p>
<p>除了都以锁来实现外，以上四种隔离级别还有另外一个共同特点，就是幻读、不可重复读、脏读等问题都是由于一个事务在读数据的过程中，受另外一个写数据的事务影响而破坏了隔离性。针对这种“<code>一个事务读+另一个事务写</code>”的隔离问题，近年来有一种名为“多版本并发控制”（Multi-Version Concurrency Control，MVCC）的<code>无锁优化</code>方案被主流的商业数据库广泛采用。</p>
<p>MVCC是一种读取优化策略，它的“无锁”特指读取时不需要加锁。MVCC的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是<code>产生一个新版本与老版本共存</code>，以此达到读取时可以完全不加锁的目的。在这句话中，“版本”是个关键词，你不妨将版本理解为数据库中每一行记录都存在两个看不见的字段：<code>CREATE_VERSION</code>和<code>DELETE_VERSION</code>，这两个字段记录的值都是<code>事务ID</code>，事务ID是一个全局严格递增的数值，然后根据以下规则写入数据。</p>
<ul>
<li>插入数据时：CREATE_VERSION记录插入数据的事务ID，DELETE_VERSION为空。</li>
<li>删除数据时：DELETE_VERSION记录删除数据的事务ID，CREATE_VERSION为空。</li>
<li>修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的DELETE_VERSION记录修改数据的事务ID，CREATE_VERSION为空。复制后的新数据的CREATE_VERSION记录修改数据的事务ID，DELETE_VERSION为空。</li>
</ul>
<p>此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。</p>
<ul>
<li>隔离级别是可重复读：总是读取CREATE_VERSION小于或等于当前事务ID的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务ID最大）的。</li>
<li>隔离级别是读已提交：总是取最新的版本即可，即最近被提交的那个版本的数据记录。</li>
</ul>
<p>另外两个隔离级别都没有必要用到MVCC，因为读未提交直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。可串行化本来的语义就是要阻塞其他事务的读取操作，而MVCC是做读取时的无锁优化的，自然不会放到一起用。</p>
<p>MVCC是只针对“读+写”场景的优化，如果是两个事务同时修改数据，即“写+写”的情况，那就没有多少优化的空间了，此时加锁几乎是唯一可行的解决方案，稍微有点讨论余地的是加锁策略是选“乐观加锁”（<code>Optimistic Locking</code>）·还是选“悲观加锁”（<code>Pessimistic Locking</code>）。</p>
<p>前面介绍的加锁都属于悲观加锁策略，即认为如果不先加锁再访问数据，就肯定会出现问题。相对地，乐观加锁策略认为事务之间数据存在竞争是偶然情况，没有竞争才是普遍情况，这样就不应该在一开始就加锁，而是应当在出现竞争时再找补救措施。这种思路也被称为“乐观并发控制”（<code>Optimistic Concurrency Control，OCC</code>）。</p>
<h3 id="32-全局事务">3.2 全局事务</h3>
<p>全局事务（Global Transaction）：外部事务（External Transaction），与本地事务相对的是全局事务（Global Transaction）。全局事务被限定为一种适用于<code>单个服务使用多个数据源</code>场景的事务解决方案。</p>
<p><strong>JTA</strong>:</p>
<p>XA并不是Java的技术规范（XA提出那时还没有Java），而是一套语言无关的通用规范，所以Java中专门定义了<code>JSR 907 Java Transaction API</code>，基于XA模式在Java语言中实现了全局事务处理的标准，这也是我们现在所熟知的JTA。</p>
<p>JTA最主要的两个接口如下。</p>
<ul>
<li>
<p>事务管理器的接口：<code>javax.transaction.TransactionManager</code>。这套接口用于为Java EE服务器提供容器事务（由容器自动负责事务管理）。</p>
<p>JTA还提供了另外一套<code>javax.transaction.UserTransaction接口</code>，用于通过程序代码手动开启、提交和回滚事务。</p>
</li>
<li>
<p>满足XA规范的资源定义接口：<code>javax.transaction.xa.XAResource</code>。任何资源（JDBC、JMS等）如果想要支持JTA，只要实现XAResource接口中的方法即可。</p>
</li>
</ul>
<p>JTA原本是Java EE中的技术，一般情况下应该由<code>JBoss、WebSphere、WebLogic</code>这些<code>Java EE容器</code>来提供支持，但现在<code>Bittronix、Atomikos和JBossTM（以前叫Arjuna）</code>都以<code>JAR包</code>的形式实现了JTA的接口，称为<code>JOTM（Java Open Transaction Manager，Java开源事务管理器）</code>，使得我们也能够在<code>Tomcat、Jetty这样的Java SE环境</code>下使用JTA。</p>
<p>如果书店的用户、商家、仓库分别处于不同的数据库中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">buyBook</span><span class="o">(</span><span class="n">PaymentBill</span> <span class="n">bill</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">userTransaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">warehouseTransaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">bussinessTransaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">userAccountService</span><span class="o">.</span><span class="na">pay</span><span class="o">(</span><span class="n">bill</span><span class="o">.</span><span class="na">getMoney</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">warehouseService</span><span class="o">.</span><span class="na">deliver</span><span class="o">(</span><span class="n">bill</span><span class="o">.</span><span class="na">getItems</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">businessAccountService</span><span class="o">.</span><span class="na">receipt</span><span class="o">(</span><span class="n">bill</span><span class="o">.</span><span class="na">getMoney</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">userTransaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">warehouseTransaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">businessTransaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}(</span><span class="k">catch</span> <span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">userTransaction</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">warehouserTransaction</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">businessTransaction</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从代码可以看出，程序的目的是做三次事务提交，但实际上代码并不能这样写，试想一下，如果在<code>businessTransaction.commit()</code>中出现错误，代码转到catch块中执行，此时<code>userTransaction</code>和<code>warehouseTransaction</code>已经完成提交，再去调用rollback()方法已经无济于事，这将导致一部分数据被提交，另一部分被回滚，整个事务的一致性也就无法保证了。</p>
<p>为了解决这个问题，XA将事务提交拆分成两阶段。</p>
<p>1、准备阶段：又叫作<code>投票阶段</code>，在这一阶段，<code>协调者</code>询问事务的<code>所有参与者</code>是否准备好提交，参与者如果已经准备好提交则回复<code>Prepared</code>，否则回复<code>Non-Prepared</code>。这里所说的准备操作跟人类语言中通常理解的准备不同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是<code>暂不写入最后一条Commit Record</code>而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。</p>
<p>2、提交阶段：又叫作<code>执行阶段</code>，协调者如果在上一阶段收到所有事务参与者回复的Prepared消息，则先自己在本地持久化事务状态为Commit，然后向所有参与者发送Commit指令，让所有参与者立即执行提交操作；否则，任意一个参与者回复了Non-Prepared消息，或任意一个参与者超时未回复时，协调者将在自己完成事务状态为<code>Abort持久化</code>后，向所有参与者发送<code>Abort指令</code>，让参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条Commit Record而已，通常能够快速完成，只有收到Abort指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载操作。</p>
<p>以上这两个过程被称为“两段式提交”（2 Phase Commit，2PC）协议，而它能够成功保证一致性还需要一些其他前提条件。</p>
<ul>
<li>必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息。同时也假设网络通信在全过程都不会出现误差，即可以丢失消息，但不会传递错误的消息，XA的设计目标并不是解决诸如<code>拜占庭将军</code>一类的问题。在两段式提交中，投票阶段失败了可以补救（回滚），提交阶段失败了则无法补救（不再改变提交或回滚的结果，只能等崩溃的节点重新恢复），因而此阶段耗时应尽可能短，这也是为了尽量控制网络风险。</li>
<li>必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。由于在准备阶段已经写入了完整的重做日志，所以当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，进而向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作。</li>
</ul>
<p>两段式提交原理简单，并不难实现，但有几个非常显著的缺点。</p>
<ul>
<li>单点问题：协调者在两段式提交中具有举足轻重的作用，协调者等待参与者回复时可以有超时机制，允许参与者宕机，但参与者等待协调者指令时无法做超时处理。一旦宕机的不是其中某个参与者，而是协调者的话，所有参与者都会受到影响。如果协调者一直没有恢复，没有正常发送Commit或者Rollback的指令，那所有参与者都必须一直等待。</li>
<li>性能问题：在两段式提交过程中，所有参与者相当于被绑定为一个统一调度的整体，期间要经过<code>两次远程服务调用</code>，<code>三次数据持久化</code>（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入提交记录），整个过程将持续到参与者集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差。</li>
<li>一致性风险：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。宕机恢复能力这一点不必多谈，1985年Fischer、Lynch、Paterson提出了“FLP不可能原理”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。该原理在分布式中是与CAP不可兼得原理齐名的理论。而网络稳定性带来的一致性风险是指：尽管提交阶段时间很短，但这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态是可以提交的，协调者会先持久化事务状态，并提交自己的事务，如果这时候网络忽然断开，无法再通过网络向所有参与者发出Commit指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）未提交，且没有办法回滚，产生数据不一致的问题。</li>
</ul>
<p>为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了<code>“三段式提交”（3 Phase Commit，3PC）</code>协议。三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为<code>CanCommit、PreCommit</code>，把提交阶段改称为<code>DoCommit</code>阶段。其中，新增的CanCommit是一个询问阶段，即协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。将准备阶段一分为二的理由是这个阶段是重负载的操作，一旦协调者发出开始准备的消息，每个参与者都将马上开始写重做日志，它们所涉及的数据资源即被锁住，如果此时某一个参与者宣告无法完成提交，相当于大家都做了一轮无用功。所以，增加一轮询问阶段，如果都得到了正面的响应，那事务能够成功提交的把握就比较大了，这也意味着因某个参与者提交时发生崩溃而导致大家全部回滚的风险相对变小。因此，在事务需要回滚的场景中，三段式提交的性能通常要比两段式提交好很多，但在事务能够正常提交的场景中，两者的性能都很差，甚至三段式因为多了一次询问，还要稍微更差一些。</p>
<p>同样也是由于事务失败回滚概率变小，在三段式提交中，如果在PreCommit阶段之后发生了协调者宕机，即参与者没有等到DoCommit的消息的话，默认的操作策略将是提交事务而不是回滚事务或者持续等待，这就相当于避免了协调者单点问题的风险。</p>
<h2 id="第4章-透明多级分流系统">第4章 透明多级分流系统</h2>
<h2 id="第5章-架构安全性">第5章 架构安全性</h2>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Anjana</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2022-04-02
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a href="https://github.com/gohugoio/hugoBasicExample" rel="noopener" target="_blank">See origin</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://anjanavakil.github.io/tags/cs/">CS💻</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/sql/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">SQL</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/the-fenix-project1/">
            <span class="next-text nav-default">《凤凰架构》演进中的架构</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:anjana.cheng@qq.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/AnjanaVakil" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.douban.com/people/188748525/?_i=5959211pTN39WJ,5959254pTN39WJ" rel="me noopener" class="iconfont"
      title="douban"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M926.917973 37.80608C959.65184 37.80608 986.19392 64.34816 986.19392 97.082027L986.19392 926.917973C986.19392 959.65184 959.65184 986.19392 926.917973 986.19392L97.082027 986.19392C64.34816 986.19392 37.80608 959.65184 37.80608 926.917973L37.80608 97.082027C37.80608 64.34816 64.34816 37.80608 97.082027 37.80608zM176.653653 176.19968 176.653653 252.678827 825.658027 252.678827 825.658027 176.19968zM217.719467 316.146347 217.719467 628.08064 273.524053 628.08064 341.292373 770.39616 157.259093 770.39616 157.259093 845.417813 842.949973 845.417813 842.949973 770.39616 654.226773 770.39616 722.899627 628.08064 783.67744 628.08064 783.67744 316.146347zM684.885333 392.891733 684.885333 553.987413 312.576 553.987413 312.576 392.891733zM570.770773 770.39616 426.653013 770.39616 359.621973 628.08064 639.443627 628.08064z"></path>
</svg>

    </a>


<a href="https://anjanavakil.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2021 -
    2022
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Anjana
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
